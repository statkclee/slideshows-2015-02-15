<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />

    <title>과학 컴퓨팅의 업무처리 모범 규준(Best Practice)</title>
    <meta name="author" content="Thomas Arildsen" />
    <meta name="author" content="Greg Wilson" />
    <!-- meta name="audio" content="voiceover.ogg" -->
    <!-- meta name="timings" content="timings.json" -->

    <script src="../js/deckjs-custom.js"></script>
    <script>includedeck(["../css/software-carpentry.css"],{});</script>
    <style>
      .slide.title-slide h1 {padding-bottom: 0;} /* title is long... */
      a {text-decoration: underline;} /* make links clearer */
      pre {font-size: 75%;} /* make code blocks smaller */
      p.rule {text-align: center; font-style: italic; } /* make lessons larger */
      p.small {font-size: 80%;}
      h3.rule {text-align: center; color: #2b3990;}
    </style>
  </head>
  <body>
    <div class="deck-container">

      <section class="slide title-slide" data-container-class="no-status">
        <h1 style="font-size: 210%;">과학 컴퓨팅의 업무처리 <br/>모범 규준(Best Practice)</h1>
        <p>2015년 1월</p>
        <img class="logo" src="../img/software-carpentry-banner.png" alt="Software Carpentry Logo" />
      </section>

      <section class="slide">
	<h2>배경</h2>
	<ul>
	  <li>소프트웨어는 21세기 연구장비.</li>
	  <li>과학자가 소프트웨어 작성에 많은 시간을 투여.</li>
	  <li>하지만, 90%이상 과학자가 소프트웨어를 독학.</li>
	  <li>"좋은" 소프트웨어 의미를 모름.</li>
	  <li>그래서, 8개 범주 24개 모범규준(Practice)을 기술.</li>
	</ul>
      </section>

      <section class="slide">
	<h4 align="center">좋은 프로그래머가 평균보다<br/>10배 더 생산성이 높다.</h4>
      </section>

      <section class="slide">
	<h4 align="center">
		좋은 <strike>프로그래머</strike>가 평균보다<br/>10배 더 생산성이 높다.</h4>
      </section>

      <section class="slide">
	<h4 align="center">
		좋은 <em><strong>모범규준(Practice)</strong></em>가 평균보다<br/>10배 더 생산성이 높다.</h4>
      </section>

      <section class="slide">
	<h2>규칙 1</h2>
	<h3 class="rule">사람을 위한 프로그램을 작성하라.
		        <br/>컴퓨터를 위해서가 아니다.</h3>
	<ul>
	  <li>이해하기 어려운 코드는 무슨 기능을 수행하는지 분간하기가 어렵다.</li>
	  <li>다른 동료 과학자가 재사용하기도 어렵다...</li>
	  <li>...미래의 본인 자신도 포함된다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 1a</h2>
	<p class="rule">한번에 프로그램을 읽는 사람 머리속에 소수의 사실만 기억하도록 프로그램이 작성되어야 한다.</p>
	<ul>
	  <li>사람 단기 기억은 7&plusmn;2 가지만 기억한다.</li>
	  <li>그래서, 프로그램을 매개변수가 몇개 있는 짧고, 읽기 쉬운 함수로 쪼개야 한다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 1b</h2>
	<p class="rule">이름은 일관되고, 독특하고, 의미있게 명명한다.</p>
	<ul>
	  <li><code>p</code>는 <code>pressure</code>(압력)만큼 독자의 단기 기억에 도움이 되지 않는 이름이다.</li>
	  <li><code>temp</code>를 사용하지 말라. "temporary"(임시)와 "temperature"(온도)를 의미할 수 있다.</li>
	  <li>단, <code>i</code>, <code>j</code>가 적은 유효 범위(scope)를 가지는 인덱스에 사용될 때는 OK.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 1c</h2>
	<p class="rule">코드 작성 스타일과 형식을 일관되게 하라.</p>
	<ul>
	  <li><em>어떤</em> 코드 작성 규칙인지 관계없다. &mdash; 규칙을 <em>갖는게</em> 중요한다.</li>
	  <li>뇌는 모든 차이가 특별한 의미가 있다고 가정한다.</li>
	  <li>모든 불일관성이 이해를 떨어뜨린다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 2</h2>
	<h3 class="rule">컴퓨터가 작업을 처리하게 하라.</h3>
	<ul>
	  <li>컴퓨터의 존재이유는 빨리 작업을 반복하는데 있다.</li>
	  <li>99% 정확성 &rArr; 100번 반복에 한번 오류가 있는 경우 63% 오류 가능성 의미.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 2a</h2>
	<p class="rule">컴퓨터가 작업을 반복하게 하라.</p>
	<ul>
	  <li>모든 일에 작은 프로그램을 작성하라.</li>
	  <li>스크립트, 매크로, 엘리어스로 불려도 상관없다.</li>
	  <li>GUI 보다는 텍스트 기반 프로그래밍 시스템으로 하는 것이 쉽다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 2b</h2>
	<p class="rule">재사용을 위해서 파일에 최든 명령어를 저장하라.</p>
	<ul>
	  <li>대부분의 텍스트 기반 인터페이스는 자동으로 지원
	    <ul>
	      <li>최근 작업을 <code>history</code>를 사용해서 반복하라.</li>
	      <li>"소규모로 재현(Reproducibility)"</li>
	    </ul>
	  </li>
	  <li>이력을 저장하면, "대규모로 재현(Reproducibility)"도 쉽다.
	    <ul>
	      <li>결과가 도출된 방법에 대한 정확한 기록</li>
	      <li><em>만약</em> 모든 것이 수집된다면 그렇다.</li>
	    </ul>
	  </li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 2c</h2>
	<p class="rule">워크플로어(workflow)를 자동화하는 빌드(build) 도구를 사용.</p>
	<ul>
	  <li>최초 프로그램을 컴파일하는 용도로 개발</li>
	  <li>특정 파일이 다른 파일에 의존성을 가지는 경우 사용될 수 있다.</li>
	  <li>Makes는 워크플로어를 명시적으로 만든다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 3</h2>
	<h3 class="rule">점진적 변경을 한다.</h3>
	<ul>
	  <li>대부분의 과학자는 "요구사항(requirement)"이 없다.
	    <ul>
	      <li>연구자 자신이 사용자가 된다.</li>
	      <li>코드는 연구와 함께 진화한다.</li>
	    </ul>
	  </li>
	  <li>산업계에 가장 가까운 사례가 <em>애자일 개발(agile development)</em>이다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 3a</h2>
	<p class="rule">피드백을 자주 받고 경로 보정으로 <br/>작은 움직임으로 작업한다.</p>
	<ul>
	  <li>휴식없이 사람이 집중할 수 있는 시간은 45-90분 정도다.</li>
	  <li>그래서, 작업 크기를 이정도 시간에 맞춘다.</li>
	  <li>장기 사이클 주기는 1주 혹은 2주다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 3b</h2>
	<p class="rule">버젼 제어(version control) <br/> 시스템을 사용한다.</p>
	<ul>
	  <li>변경 사항을 추적한다.</li>
	  <li>실행취소(undo)가 될 수 있게 한다.</li>
	  <li>독립적인 병렬 개발을 지원한다.</li>
	  <li><a href="#collaborate">협업(collaboration)</a>에 필수적이다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 3c</h2>
	<p class="rule">버젼 제어에 수작업으로 생성한 <br/>모든 것을 저장한다.</p>
	<ul>
	  <li>소프트웨어 뿐만 아니라: 논문, 이미지, ...
	    <ul>
	      <li>기가바이트 데이터는 아니다....</li>
	      <li>...기가바이트 데이터에 <em>대한</em> 메타데이터</li>
	    </ul>
	  </li>
	  <li>컴퓨터가 생성한 것은 배제한다.
	    <ul>
	      <li>대신에 다시 생성하기 위해서 빌드(build) 도구를 사용한다.</li>
	      <li>만약 다시 생성하는데 매우 오랜 시간이 걸리지 않는다면 그렇다.</li>
	    </ul>
	  </li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 4</h2>
	<h3 class="rule">자신 (혹은 타인)을 반복하지 않는다.</h3>
	<ul>
	  <li>두곳이상에서 반복되는 어떤 것이든지 결국 적어도 한 곳에서 잘못된다.</li>
	  <li>찾거나 이해하는 것보다 다시 생성하는 것이 더 빠르다면, <em>고쳐라(fix it)</em></li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 4a</h2>
	<p class="rule">
		시스템에서 모든 데이터는 단 하나의 <br/>
		믿을만한 표현만 가져야 한다.</p>
	<ul>
	  <li>상수(constant)는 정확히 한번 정의한다.</li>
	  <li>파일 형식, 지리 정보, ... 등도 동일하다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 4b</h2>
	<p class="rule">코드를 CV신공(복사-붙여넣기)보다는 모듈화하라.</p>
	<ul>
	  <li>코드 복제(code cloning)를 줄이면 오류가 줄어든다.</li>
	  <li>테스팅 업무량을 줄여라.</li>
	  <li>이해도(comprehension)를 높여라.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 4c</h2>
	<p class="rule">코드를 다시 작성하지 말고 재사용하라.</p>
	<ul>
	  <li>품질 좋은 수치해석 혹은 통계 소프트웨어를 개발하는데 수년의 전문가 시간이 소요된다.</li>
	  <li>이 기반위에서 과학에 더 많은 시간을 보내는 것이 낫다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 5</h2>
	<h3 class="rule">실수에 대한 대비</h3>
	<ul>
	  <li>단 하나의 모범규준(practice)이 모든걸 해결하지 못한다.</li>
	  <li>그래서, <em>심도깊게 방어</em> 실습한다.</li>
	</ul>
	<p align="center"><em>주석: 품질을 높이면 생산성이 올라간다.</em></p>
      </section>

      <section class="slide">
	<h2>규칙 5a</h2>
	<p class="rule">프로그램이 동작을 검증하는데 가정 설정문(assertions)을 추가하라.</p>
	<ul>
	  <li>"여기는 참(true)으로 문제가 없다. 혹은 오류가 있다"</li>
	  <li>하드웨어에 진단 회로와 같은 역할</li>
	  <li>만약 프로그램이 고장난 경우 보정 절차에 대한 안내는 없다...</li>
	  <li>...<em>실행가능한 문서(executable documentation)</em>로 역할 수행.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 5b</h2>
	<p class="rule">범용 단위 테스트 라이브러리를 사용한다.</p>
	<ul>
	  <li>설치, 환경설정, 실행, 보고서 작성을 관리한다.</li>
	  <li>코드가 매번 변경될 때 <em>회귀 테스트(regression test)</em>를 통해서 단위 테스트를 다시 실행한다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>테스팅은 어렵다.</h2>
	<ul>
	  <li>"정답이 무엇인지 알고 있다면, 당장 논문을 발표할 것이다."</li>
	  <li>실험 데이터와 비교하거나,</li>
	  <li>단순한 문제의 해석적인 해와 비교하거나,</li>
	  <li>예전 (신임된) 프로그램과 비교한다.</li>
	  <li>만약 그외의 경우라면, 수용가능한 "오류"범위가 얼마인지 문서화한다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 5c</h2>
	<p class="rule">버그를 테스트 사례(test case)로 바꿔 놓는다.</p>
	<ul>
	  <li>만약 버그가 존재한다면, 실패하는 테스트를 작성한다.</li>
	  <li>그리고 나서, 테스트가 통과할 때까지 코드 개발 작업한다...</li>
	  <li>...그리고 다른 것들은 실패하지 않는다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>테스트 주도 개발</h2>
	<ul>
	  <li>왜 기다려야 하죠? 항상 테스트를 작성하고, 코드를 작성하라.</li>
	  <li>초점이 되는 진원지를 개선한다.</li>
	  <li>테스트 가능한 코드를 작성하게 격려한다.</li>
	  <li>그리고, 테스트가 실제로 작성되었는지 확실히 한다...</li>
	  <li>테스트 주도 개발 리듬 "레드(Red), 그린(green), 리팩터(refactor)"</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 5d</h2>
	<p class="rule">기호 결함 수정자(symbolic debugger)를 사용하라.</p>
	<ul>
	  <li>프로그램이 실행하며 프로그램을 탐구한다.</li>
	  <li><code>print</code> 문장보다 좋다.
	    <ul>
	      <li>다시 실행해야할 필요가 없다...</li>
	      <li>...혹은 미리 알 필요가 있는 것을 추측한다.</li>
	    </ul>
	  </li>
	  <li><em>breakpoints</em>를 사용해서 특정한 지점에서, 혹은 특정한 것이 참일대 프로그램을 정지한다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>Rule 6</h2>
	<h3 class="rule">올바르게 동작하는 뒤에야<br/>소프트웨어를 최적화한다.</h3>
	<ul>
	  <li>심지어 전문가조차도 성능 병목지점을 예측하기 어렵다.</li>
	  <li>종종 코드에 작은 변경이 성능에 극적인 영향을 끼친다.</li>
	  <li>그래서, 소프트웨어를 올바르게 만든다. <em>그리고 나서</em> 빠르게 만든다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 6a</h2>
	<p class="rule">병목지점을 식별하는데 프로파일러(profiler)를 사용한다.</p>
	<ul>
	  <li>각 코드라인별로 얼마나 시간이 소요되었는지 기록한다.</li>
	  <li>새로운 컴퓨터나 라이브러리를 바꿔서 다시 검증한다.</li>
	  <li>단위 테스트를 거쳐 요약한다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 6b</h2>
	<p class="rule">가능한면 가장 높은 수준(highest-level) 언어로 코드를 작성한다.</p>
	<ul>
	  <li>언어에 관계없이, 시간당 동일한 코드 라인을 작성한다.</li>
	  <li>그래서, "올바르게 동작하는" 버젼을 개발하는데 이용가능한 가장 표현력이 큰 언어를 사용한다...</li>
	  <li>...그리고 나서 "빠른" 버젼이 되도록 (아마도 좀더 낮은 수준(lower-leve) 언어로) 핵심 부분을 다시 작성한다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 7</h2>
	<h3 class="rule">디자인과 의도를 문서화하라.<br/>기계적인 부분은 문서화하지 마라.</h3>
	<ul>
	  <li>목표가 다음 사람 인생을 좀더 쉽게 한다.</li>
	  <li>코드가 말하지 <em>않는</em> 것에 초점을 맞춰라.
	    <ul>
	      <li>혹은 명확히 말하지 않는 것</li>
	      <li>예를 들어, 파일 형식</li>
	    </ul>
	  </li>
	  <li>예제 하나가 천마디 단어보다 가치가 있다...</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 7a</h2>
	<p class="rule">인터페이스와 사유를 문서화하라, <br/>구현을 문서화하지 마라.</p>
	<ul>
	  <li>인터페이스와 사유 변경이 세부 구현보다 좀더 천천히 변경된다. 그래서 인터페이스와 사유를 문서화하는 것이 좀더 경제적이다.</li>
	  <li>사람 대부분은 코드를 이해하는 것보다 사용하는데 관심이 있다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 7b</h2>
	<p class="rule">코드 동작을 설명하는 것보다 <br/> 우선해서 코드를 리팩터한다.</p>
	<ul>
	  <li>소리내어 읽게 되면, 좋은 코드는 이해될 수 있다.</li>
	  <li>좋은 프로그래머는 라이브러리를 개발해서 문제 해결이 간단한다.</li>
	  <li>다시, "레드, 그린, 리팩터"</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 7c</h2>
	<p class="rule">소프트웨어 내부에 소프트웨어 조각에 대한 문서를 내장한다.</p>
	<ul>
	  <li>특정 형식의 주석 혹은 문자열</li>
	  <li>좀더 최신정보로 갱신될 듯 하다.</li>
	  <li>인터랙티브 도움말에 좀더 접근성이 좋다.</li>
	  <li>많은 최신 도구는 문서화를 코드에 내장한다.(문서에 코드를 내장하기보다)</li>
	</ul>
      </section>

      <section class="slide">
        <h2 id="collaborate">규칙 8</h2>
	<h3 class="rule">협업하라.(Collaborate)</h3>
	<ul>
	  <li>컴퓨터는 계산하기 위해서 발명되었다.</li>
	  <li>웹은 협업하기 위해서 발명되었다.</li>
	  <li>과학은 공유될 때, 좀더 재밌다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 8a</h2>
	<p class="rule">사전 병합(pre-merge) 코드 리뷰를 사용한다.</p>
	<ul>
	  <li>버젼 제어 시스템에 병합하기 <em>전에</em> 다른 누군가 변경사항을 리뷰하게 시킨다.</li>
	  <li>엄청나게 오류가 줄어든다.</li>
	  <li>지식을 공유하는 좋은 방법</li>
	  <li>이것이 공개 소프트웨어(open source)를 가능하게 만드는 것이다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 8b</h2>
	<p class="rule"> 새로운 누군가 빨리 적응시키고자 할때, <br/>
	    특히, 까다로운 문제를 다룰 때 <br/>
	    페어 프로그래밍(pair programming)을 사용한다.</p>
	<ul>
	  <li>두명, 키보드 한개, 화면 한개</li>
	  <li>코드 리뷰의 극단적인 형태</li>
	  <li>아주 자주 한다면, 다소 지칠수도 있다...</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 8c</h2>
	<p class="rule">이슈 추적 도구를 사용한다.</p>
	<ul>
	  <li>공유 작업 목록 (shared to-do list)
	    <ul>
	      <li>작업항목이 사람에게 할당될 수 있다.</li>
	      <li>주석, 코드와 논문에 링크 등을 지원한다.</li>
	    </ul>
	  </li>
	  <li>"버젼 제어(version control)는 갔던 장소를 이슈 추적(issue tracker)은 가고 있는 방향이다."<br/>
	  <em>"Version control is where we've been, the issue tracker is where we're going"</em></li>
	</ul>
      </section>

      <section class="slide">
	<h2>이런, 엄청 많네...</h2>
	<p class="rule">한번에 하나씩.</p>
	<ol>
	  <li>텍스트 기반 인터페이스 사용한다.</li>
	  <li><code>history</code>를 스크립트로 변환한다.</li>
	  <li>모든 것을 버젼 제어 시스템에 넣는다.</li>
	  <li>테스트 주도 개발 사용한다.</li>
	</ol>
      </section>

      <section class="slide" data-container-class="no-status">
        <h2 style="font-size: 160%;">감사합니다.</h2>
	<p class="small">
	  Greg Wilson,
	  D. A. Aruliah,
	  C. Titus Brown,
	  Neil P. Chue Hong,
	  Matt Davis,
	  Richard T. Guy,
	  Steven H.D. Haddock,
	  Kathryn D. Huff,
	  Ian M. Mitchell,
	  Mark D. Plumbley,
	  Ben Waugh,
	  Ethan P. White,
	  and
	  Paul Wilson:
	</p>
	<p align="center">
	  "Best Practices for Scientific Computing"
	  <br/>
	  PLOS Biology, Jan. 2014,
	  <br/>
	  <a href="http://dx.doi.org/10.1371/journal.pbio.1001745">http://dx.doi.org/10.1371/journal.pbio.1001745</a>.
	</p>
	<div align="center">
          <p><img src="../img/software-carpentry-banner.png" alt="Software Carpentry Logo" /></p>
	</div>
      </section>

    </div>
  </body>
</html>
