<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />

    <title>과학 컴퓨팅의 업무처리 모범 규준(Best Practice)</title>
    <meta name="author" content="Thomas Arildsen" />
    <meta name="author" content="Greg Wilson" />
    <!-- meta name="audio" content="voiceover.ogg" -->
    <!-- meta name="timings" content="timings.json" -->

    <script src="../js/deckjs-custom.js"></script>
    <script>includedeck(["../css/software-carpentry.css"],{});</script>
    <style>
      .slide.title-slide h1 {padding-bottom: 0;} /* title is long... */
      a {text-decoration: underline;} /* make links clearer */
      pre {font-size: 75%;} /* make code blocks smaller */
      p.rule {text-align: center; font-style: italic; } /* make lessons larger */
      p.small {font-size: 80%;}
      h3.rule {text-align: center; color: #2b3990;}
    </style>
  </head>
  <body>
    <div class="deck-container">

      <section class="slide title-slide" data-container-class="no-status">
        <h1 style="font-size: 210%;">과학 컴퓨팅의 업무처리 <br/>모범 규준(Best Practice)</h1>
        <p>2015년 1월</p>
        <img class="logo" src="../img/software-carpentry-banner.png" alt="Software Carpentry Logo" />
      </section>

      <section class="slide">
	<h2>배경</h2>
	<ul>
	  <li>소프트웨어는 21세기 연구장비.</li>
	  <li>과학자가 소프트웨어 작성에 많은 시간을 투여.</li>
	  <li>하지만, 90%이상 과학자가 소프트웨어를 독학.</li>
	  <li>"좋은" 소프트웨어 의미를 모름.</li>
	  <li>그래서, 8개 범주 24개 모범규준(Practice)을 기술.</li>
	</ul>
      </section>

      <section class="slide">
	<h4 align="center">좋은 프로그래머가 평균보다<br/>10배 더 생산성이 높다.</h4>
      </section>

      <section class="slide">
	<h4 align="center">
		좋은 <strike>프로그래머</strike>가 평균보다<br/>10배 더 생산성이 높다.</h4>
      </section>

      <section class="slide">
	<h4 align="center">
		좋은 <em><strong>모범규준(Practice)</strong></em>가 평균보다<br/>10배 더 생산성이 높다.</h4>
      </section>

      <section class="slide">
	<h2>규칙 1</h2>
	<h3 class="rule">사람을 위한 프로그램을 작성하라.
		        <br/>컴퓨터를 위해서가 아니다.</h3>
	<ul>
	  <li>이해하기 어려운 코드는 무슨 기능을 수행하는지 분간하기가 어렵다.</li>
	  <li>다른 동료 과학자가 재사용하기도 어렵다...</li>
	  <li>...미래의 본인 자신도 포함된다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 1a</h2>
	<p class="rule">한번에 프로그램을 읽는 사람 머리속에 소수의 사실만 기억하도록 프로그램이 작성되어야 한다.</p>
	<ul>
	  <li>사람 단기 기억은 7&plusmn;2 가지만 기억한다.</li>
	  <li>그래서, 프로그램을 매개변수가 몇개 있는 짧고, 읽기 쉬운 함수로 쪼개야 한다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 1b</h2>
	<p class="rule">이름은 일관되고, 독특하고, 의미있게 명명한다.</p>
	<ul>
	  <li><code>p</code>는 <code>pressure</code>(압력)만큼 독자의 단기 기억에 도움이 되지 않는 이름이다.</li>
	  <li><code>temp</code>를 사용하지 말라. "temporary"(임시)와 "temperature"(온도)를 의미할 수 있다.</li>
	  <li>단, <code>i</code>, <code>j</code>가 적은 유효 범위(scope)를 가지는 인덱스에 사용될 때는 OK.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 1c</h2>
	<p class="rule">코드 작성 스타일과 형식을 일관되게 하라.</p>
	<ul>
	  <li><em>어떤</em> 코드 작성 규칙인지 관계없다. &mdash; 규칙을 <em>갖는게</em> 중요한다.</li>
	  <li>뇌는 모든 차이가 특별한 의미가 있다고 가정한다.</li>
	  <li>모든 불일관성이 이해를 떨어뜨린다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 2</h2>
	<h3 class="rule">컴퓨터가 작업을 처리하게 하라.</h3>
	<ul>
	  <li>컴퓨터의 존재이유는 빨리 작업을 반복하는데 있다.</li>
	  <li>99% 정확성 &rArr; 100번 반복에 한번 오류가 있는 경우 63% 오류 가능성 의미.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 2a</h2>
	<p class="rule">컴퓨터가 작업을 반복하게 하라.</p>
	<ul>
	  <li>모든 일에 작은 프로그램을 작성하라.</li>
	  <li>스크립트, 매크로, 엘리어스로 불려도 상관없다.</li>
	  <li>GUI 보다는 텍스트 기반 프로그래밍 시스템으로 하는 것이 쉽다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 2b</h2>
	<p class="rule">재사용을 위해서 파일에 최든 명령어를 저장하라.</p>
	<ul>
	  <li>대부분의 텍스트 기반 인터페이스는 자동으로 지원
	    <ul>
	      <li>최근 작업을 <code>history</code>를 사용해서 반복하라.</li>
	      <li>"소규모로 재현(Reproducibility)"</li>
	    </ul>
	  </li>
	  <li>이력을 저장하면, "대규모로 재현(Reproducibility)"도 쉽다.
	    <ul>
	      <li>결과가 도출된 방법에 대한 정확한 기록</li>
	      <li><em>만약</em> 모든 것이 수집된다면 그렇다.</li>
	    </ul>
	  </li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 2c</h2>
	<p class="rule">워크플로어(workflow)를 자동화하는 빌드(build) 도구를 사용.</p>
	<ul>
	  <li>최초 프로그램을 컴파일하는 용도로 개발</li>
	  <li>특정 파일이 다른 파일에 의존성을 가지는 경우 사용될 수 있다.</li>
	  <li>Makes는 워크플로어를 명시적으로 만든다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 3</h2>
	<h3 class="rule">점진적 변경을 한다.</h3>
	<ul>
	  <li>대부분의 과학자는 "요구사항(requirement)"이 없다.
	    <ul>
	      <li>연구자 자신이 사용자가 된다.</li>
	      <li>코드는 연구와 함께 진화한다.</li>
	    </ul>
	  </li>
	  <li>산업계에 가장 가까운 사례가 <em>애자일 개발(agile development)</em>이다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 3a</h2>
	<p class="rule">피드백을 자주 받고 경로 보정으로 <br/>작은 움직임으로 작업한다.</p>
	<ul>
	  <li>휴식없이 사람이 집중할 수 있는 시간은 45-90분 정도다.</li>
	  <li>그래서, 작업 크기를 이정도 시간에 맞춘다.</li>
	  <li>장기 사이클 주기는 1주 혹은 2주다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 3b</h2>
	<p class="rule">버젼 제어(version control) <br/> 시스템을 사용한다.</p>
	<ul>
	  <li>변경 사항을 추적한다.</li>
	  <li>실행취소(undo)가 될 수 있게 한다.</li>
	  <li>독립적인 병렬 개발을 지원한다.</li>
	  <li><a href="#collaborate">협업(collaboration)</a>에 필수적이다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 3c</h2>
	<p class="rule">버젼 제어에 수작업으로 생성한 <br/>모든 것을 저장한다.</p>
	<ul>
	  <li>소프트웨어 뿐만 아니라: 논문, 이미지, ...
	    <ul>
	      <li>기가바이트 데이터는 아니다....</li>
	      <li>...기가바이트 데이터에 <em>대한</em> 메타데이터</li>
	    </ul>
	  </li>
	  <li>컴퓨터가 생성한 것은 배제한다.
	    <ul>
	      <li>대신에 다시 생성하기 위해서 빌드(build) 도구를 사용한다.</li>
	      <li>만약 다시 생성하는데 매우 오랜 시간이 걸리지 않는다면 그렇다.</li>
	    </ul>
	  </li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 4</h2>
	<h3 class="rule">자신 (혹은 타인)을 반복하지 않는다.</h3>
	<ul>
	  <li>두곳이상에서 반복되는 어떤 것이든지 결국 적어도 한 곳에서 잘못된다.</li>
	  <li>찾거나 이해하는 것보다 다시 생성하는 것이 더 빠르다면, <em>고쳐라(fix it)</em></li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 4a</h2>
	<p class="rule">
		시스템에서 모든 데이터는 단 하나의 <br/>
		믿을만한 표현만 가져야 한다.</p>
	<ul>
	  <li>상수(constant)는 정확히 한번 정의한다.</li>
	  <li>파일 형식, 지리 정보, ... 등도 동일하다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 4b</h2>
	<p class="rule">코드를 CV신공(복사-붙여넣기)보다는 모듈화하라.</p>
	<ul>
	  <li>코드 복제(code cloning)를 줄이면 오류가 줄어든다.</li>
	  <li>테스팅 업무량을 줄여라.</li>
	  <li>이해도(comprehension)를 높여라.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 4c</h2>
	<p class="rule">코드를 다시 작성하지 말고 재사용하라.</p>
	<ul>
	  <li>품질 좋은 수치해석 혹은 통계 소프트웨어를 개발하는데 수년의 전문가 시간이 소요된다.</li>
	  <li>이 기반위에서 과학에 더 많은 시간을 보내는 것이 낫다.</li>
	</ul>
      </section>

      <section class="slide">
        <h2>규칙 5</h2>
	<h3 class="rule">실수에 대한 대비</h3>
	<ul>
	  <li>단 하나의 모범규준(practice)이 모든걸 해결하지 못한다.</li>
	  <li>그래서, <em>심도깊게 방어</em> 실습한다.</li>
	</ul>
	<p align="center"><em>주석: 품질을 높이면 생산성이 올라간다.</em></p>
      </section>

      <section class="slide">
	<h2>규칙 5a</h2>
	<p class="rule">프로그램이 동작을 검증하는데 가정 설정문(assertions)을 추가하라.</p>
	<ul>
	  <li>"여기는 참(true)으로 문제가 없다. 혹은 오류가 있다"</li>
	  <li>하드웨어에 진단 회로와 같은 역할</li>
	  <li>만약 프로그램이 고장난 경우 보정 절차에 대한 안내는 없다...</li>
	  <li>...<em>실행가능한 문서(executable documentation)</em>로 역할 수행.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 5b</h2>
	<p class="rule">범용 단위 테스트 라이브러리를 사용한다.</p>
	<ul>
	  <li>설치, 환경설정, 실행, 보고서 작성을 관리한다.</li>
	  <li>코드가 매번 변경될 때 <em>회귀 테스트(regression test)</em>를 통해서 단위 테스트를 다시 실행한다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>테스팅은 어렵다.</h2>
	<ul>
	  <li>"정답이 무엇인지 알고 있다면, 당장 논문을 발표할 것이다."</li>
	  <li>실험 데이터와 비교하거나,</li>
	  <li>단순한 문제의 해석적인 해와 비교하거나,</li>
	  <li>예전 (신임된) 프로그램과 비교한다.</li>
	  <li>만약 그외의 경우라면, 수용가능한 "오류"범위가 얼마인지 문서화한다.</li>
	</ul>
      </section>

      <section class="slide">
	<h2>규칙 5c</h2>
	<p class="rule">버그를 테스트 사례(test case)로 바꿔 놓는다.</p>
	<ul>
	  <li>만약 버그가 존재한다면, 실패하는 테스트를 작성한다.
	  	Write a test that fails when the bug is present</li>
	  <li>Then work on the code until that test passes...</li>
	  <li>...and no others are failing</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Test-Driven Development</h2>
	<ul>
	  <li>Why wait? Always write the tests, then the code</li>
	  <li>Improves focus</li>
	  <li>Encourages writing testable code</li>
	  <li>And ensures tests actually get written...</li>
	  <li>"Red, green, refactor"</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 5d</h2>
	<p class="rule">Use a symbolic debugger.</p>
	<ul>
	  <li>Explore the program as it runs</li>
	  <li>Better than print statements
	    <ul>
	      <li>You don't have to re-run...</li>
	      <li>...or guess in advance what you'll need to know</li>
	    </ul>
	  </li>
	  <li>Use <em>breakpoints</em> to stop program at particular points or when particular things are true</li>
	</ul>
      </section>

      <section class="slide">
        <h2>Rule 6</h2>
	<h3 class="rule">Optimize Software<br/>Only After It Works Correctly</h3>
	<ul>
	  <li>Even experts find it hard to predict performance bottlenecks</li>
	  <li>Small changes to code often have dramatic impact on performance</li>
	  <li>So get it right, <em>then</em> make it fast</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 6a</h2>
	<p class="rule">Use a profiler to identify bottlenecks.</p>
	<ul>
	  <li>Reports how much time is spent on each line of code</li>
	  <li>Re-check on new computers or when switching libraries</li>
	  <li>Summarize across unit tests</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 6b</h2>
	<p class="rule">Write code in the highest-level language possible.</p>
	<ul>
	  <li>People write the same number of lines of code per hour regardless of language</li>
	  <li>So use the most expressive language available to get the "right" version...</li>
	  <li>...then rewrite core pieces (possibly in a lower-level language) to get the "fast" version</li>
	</ul>
      </section>

      <section class="slide">
        <h2>Rule 7</h2>
	<h3 class="rule">Document Design and Purpose,<br/>not Mechanics</h3>
	<ul>
	  <li>Goal is to make the next person's life easier</li>
	  <li>Focus on things the code <em>doesn't</em> say
	    <ul>
	      <li>Or doesn't say clearly</li>
	      <li>E.g., file formats</li>
	    </ul>
	  </li>
	  <li>An example is worth a thousand words...</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 7a</h2>
	<p class="rule">Document interfaces and reasons,<br/>not implementations.</p>
	<ul>
	  <li>Interfaces and reasons change more slowly than implementation details, so documenting them is better economics</li>
	  <li>And most people care about using code more than understanding it</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 7b</h2>
	<p class="rule">Refactor code in preference to<br/>explaining how it works.</p>
	<ul>
	  <li>Good code can be understood when read aloud</li>
	  <li>Good programmers build libraries so that solving their problem is straightforward</li>
	  <li>Again, "red, green, refactor"</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 7c</h2>
	<p class="rule">Embed the documentation for a piece of software<br/>in that software.</p>
	<ul>
	  <li>Specially-formatted comments or strings</li>
	  <li>More likely to be kept up to date</li>
	  <li>More accessible to interactive help</li>
	  <li>Many modern tools embed code in documentation rather than vice versa</li>
	</ul>
      </section>

      <section class="slide">
        <h2 id="collaborate">Rule 8</h2>
	<h3 class="rule">Collaborate</h3>
	<ul>
	  <li>Computers were invented to calculate</li>
	  <li>The web was invented to collaborate</li>
	  <li>Science is more fun when it's shared</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 8a</h2>
	<p class="rule">Use pre-merge code reviews.</p>
	<ul>
	  <li>Have someone else review changes <em>before</em> merging in version control</li>
	  <li>Significantly reduces errors</li>
	  <li>Good way to share knowledge</li>
	  <li>It's what makes open source possible</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 8b</h2>
	<p class="rule">Use pair programming<br/>when bringing someone new up to speed<br/>and when tackling particularly tricky problems.</p>
	<ul>
	  <li>Two people, one keyboard, one screen</li>
	  <li>An extreme form of code review</li>
	  <li>Can get a bit tired if done all the time...</li>
	</ul>
      </section>

      <section class="slide">
	<h2>Rule 8c</h2>
	<p class="rule">Use an issue tracking tool.</p>
	<ul>
	  <li>A shared to-do list
	    <ul>
	      <li>Items can be assigned to people</li>
	      <li>Supports comments, links to code and papers, etc.</li>
	    </ul>
	  </li>
	  <li>"Version control is where we've been, the issue tracker is where we're going"</li>
	</ul>
      </section>

      <section class="slide">
	<h2>이런, 엄청 많네...</h2>
	<p class="rule">한번에 하나씩.</p>
	<ol>
	  <li>텍스트 기반 인터페이스 사용한다.</li>
	  <li>history를 스크립트로 변환한다.</li>
	  <li>모든 것을 버젼 제어(version control) 시스템에 넣는다.</li>
	  <li>테스트 주도 개발(Test-driven development) 사용한다.</li>
	</ol>
      </section>

      <section class="slide" data-container-class="no-status">
        <h2 style="font-size: 160%;">Thank You</h2>
	<p class="small">
	  Greg Wilson,
	  D. A. Aruliah,
	  C. Titus Brown,
	  Neil P. Chue Hong,
	  Matt Davis,
	  Richard T. Guy,
	  Steven H.D. Haddock,
	  Kathryn D. Huff,
	  Ian M. Mitchell,
	  Mark D. Plumbley,
	  Ben Waugh,
	  Ethan P. White,
	  and
	  Paul Wilson:
	</p>
	<p align="center">
	  "Best Practices for Scientific Computing"
	  <br/>
	  PLOS Biology, Jan. 2014,
	  <br/>
	  <a href="http://dx.doi.org/10.1371/journal.pbio.1001745">http://dx.doi.org/10.1371/journal.pbio.1001745</a>.
	</p>
	<div align="center">
          <p><img src="../img/software-carpentry-banner.png" alt="Software Carpentry Logo" /></p>
	</div>
      </section>

    </div>
  </body>
</html>
